// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.10.1
//   protoc               v6.33.3
// source: recorder.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";

export const protobufPackage = "recorder";

export interface PingMessage {
  randomId: number;
}

export interface GetStationRequest {
  stationId: number;
}

export interface UpdateSensorsRequest {
  updates: UpdateSensorRequest[];
}

export interface UpdateSensorRequest {
  sensorId: number;
  newState: SensorState | undefined;
  updateId: number;
}

export interface UpdateSensorsResponse {
  errors: string[];
  processed: number[];
}

export interface UpdateStationRequest {
  stationId: number;
  definition: StationDefinition | undefined;
}

export interface GetStationDefinitionRequest {
}

export interface StationDefinition {
  name: string;
  sensors: SensorDefinition[];
  longitude: number;
  latitude: number;
  version: number;
}

export interface SensorDefinition {
  name: string;
  element: string;
  recordIntervalSeconds: number;
}

export interface Station {
  id: number;
  sensors: Sensor[];
  version: number;
}

export interface Sensor {
  id: number;
  name: string;
  recordIntervalSeconds: number;
}

export interface GetSensorStateRequest {
  name: string;
}

export interface SensorState {
  unitId: string;
  value?: number | undefined;
  createdAt: number;
  intervalStart?: number | undefined;
}

function createBasePingMessage(): PingMessage {
  return { randomId: 0 };
}

export const PingMessage: MessageFns<PingMessage> = {
  encode(message: PingMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.randomId !== 0) {
      writer.uint32(8).int64(message.randomId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PingMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePingMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.randomId = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PingMessage {
    return { randomId: isSet(object.randomId) ? globalThis.Number(object.randomId) : 0 };
  },

  toJSON(message: PingMessage): unknown {
    const obj: any = {};
    if (message.randomId !== 0) {
      obj.randomId = Math.round(message.randomId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PingMessage>, I>>(base?: I): PingMessage {
    return PingMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PingMessage>, I>>(object: I): PingMessage {
    const message = createBasePingMessage();
    message.randomId = object.randomId ?? 0;
    return message;
  },
};

function createBaseGetStationRequest(): GetStationRequest {
  return { stationId: 0 };
}

export const GetStationRequest: MessageFns<GetStationRequest> = {
  encode(message: GetStationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stationId !== 0) {
      writer.uint32(8).int64(message.stationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.stationId = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStationRequest {
    return { stationId: isSet(object.stationId) ? globalThis.Number(object.stationId) : 0 };
  },

  toJSON(message: GetStationRequest): unknown {
    const obj: any = {};
    if (message.stationId !== 0) {
      obj.stationId = Math.round(message.stationId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetStationRequest>, I>>(base?: I): GetStationRequest {
    return GetStationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetStationRequest>, I>>(object: I): GetStationRequest {
    const message = createBaseGetStationRequest();
    message.stationId = object.stationId ?? 0;
    return message;
  },
};

function createBaseUpdateSensorsRequest(): UpdateSensorsRequest {
  return { updates: [] };
}

export const UpdateSensorsRequest: MessageFns<UpdateSensorsRequest> = {
  encode(message: UpdateSensorsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.updates) {
      UpdateSensorRequest.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateSensorsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSensorsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.updates.push(UpdateSensorRequest.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSensorsRequest {
    return {
      updates: globalThis.Array.isArray(object?.updates)
        ? object.updates.map((e: any) => UpdateSensorRequest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UpdateSensorsRequest): unknown {
    const obj: any = {};
    if (message.updates?.length) {
      obj.updates = message.updates.map((e) => UpdateSensorRequest.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSensorsRequest>, I>>(base?: I): UpdateSensorsRequest {
    return UpdateSensorsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSensorsRequest>, I>>(object: I): UpdateSensorsRequest {
    const message = createBaseUpdateSensorsRequest();
    message.updates = object.updates?.map((e) => UpdateSensorRequest.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUpdateSensorRequest(): UpdateSensorRequest {
  return { sensorId: 0, newState: undefined, updateId: 0 };
}

export const UpdateSensorRequest: MessageFns<UpdateSensorRequest> = {
  encode(message: UpdateSensorRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sensorId !== 0) {
      writer.uint32(8).int64(message.sensorId);
    }
    if (message.newState !== undefined) {
      SensorState.encode(message.newState, writer.uint32(18).fork()).join();
    }
    if (message.updateId !== 0) {
      writer.uint32(24).int64(message.updateId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateSensorRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSensorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.sensorId = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.newState = SensorState.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.updateId = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSensorRequest {
    return {
      sensorId: isSet(object.sensorId) ? globalThis.Number(object.sensorId) : 0,
      newState: isSet(object.newState) ? SensorState.fromJSON(object.newState) : undefined,
      updateId: isSet(object.updateId) ? globalThis.Number(object.updateId) : 0,
    };
  },

  toJSON(message: UpdateSensorRequest): unknown {
    const obj: any = {};
    if (message.sensorId !== 0) {
      obj.sensorId = Math.round(message.sensorId);
    }
    if (message.newState !== undefined) {
      obj.newState = SensorState.toJSON(message.newState);
    }
    if (message.updateId !== 0) {
      obj.updateId = Math.round(message.updateId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSensorRequest>, I>>(base?: I): UpdateSensorRequest {
    return UpdateSensorRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSensorRequest>, I>>(object: I): UpdateSensorRequest {
    const message = createBaseUpdateSensorRequest();
    message.sensorId = object.sensorId ?? 0;
    message.newState = (object.newState !== undefined && object.newState !== null)
      ? SensorState.fromPartial(object.newState)
      : undefined;
    message.updateId = object.updateId ?? 0;
    return message;
  },
};

function createBaseUpdateSensorsResponse(): UpdateSensorsResponse {
  return { errors: [], processed: [] };
}

export const UpdateSensorsResponse: MessageFns<UpdateSensorsResponse> = {
  encode(message: UpdateSensorsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.errors) {
      writer.uint32(10).string(v!);
    }
    writer.uint32(18).fork();
    for (const v of message.processed) {
      writer.int64(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateSensorsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSensorsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.errors.push(reader.string());
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.processed.push(longToNumber(reader.int64()));

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.processed.push(longToNumber(reader.int64()));
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSensorsResponse {
    return {
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e: any) => globalThis.String(e)) : [],
      processed: globalThis.Array.isArray(object?.processed)
        ? object.processed.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: UpdateSensorsResponse): unknown {
    const obj: any = {};
    if (message.errors?.length) {
      obj.errors = message.errors;
    }
    if (message.processed?.length) {
      obj.processed = message.processed.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSensorsResponse>, I>>(base?: I): UpdateSensorsResponse {
    return UpdateSensorsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSensorsResponse>, I>>(object: I): UpdateSensorsResponse {
    const message = createBaseUpdateSensorsResponse();
    message.errors = object.errors?.map((e) => e) || [];
    message.processed = object.processed?.map((e) => e) || [];
    return message;
  },
};

function createBaseUpdateStationRequest(): UpdateStationRequest {
  return { stationId: 0, definition: undefined };
}

export const UpdateStationRequest: MessageFns<UpdateStationRequest> = {
  encode(message: UpdateStationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stationId !== 0) {
      writer.uint32(8).int64(message.stationId);
    }
    if (message.definition !== undefined) {
      StationDefinition.encode(message.definition, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateStationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateStationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.stationId = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.definition = StationDefinition.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateStationRequest {
    return {
      stationId: isSet(object.stationId) ? globalThis.Number(object.stationId) : 0,
      definition: isSet(object.definition) ? StationDefinition.fromJSON(object.definition) : undefined,
    };
  },

  toJSON(message: UpdateStationRequest): unknown {
    const obj: any = {};
    if (message.stationId !== 0) {
      obj.stationId = Math.round(message.stationId);
    }
    if (message.definition !== undefined) {
      obj.definition = StationDefinition.toJSON(message.definition);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateStationRequest>, I>>(base?: I): UpdateStationRequest {
    return UpdateStationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateStationRequest>, I>>(object: I): UpdateStationRequest {
    const message = createBaseUpdateStationRequest();
    message.stationId = object.stationId ?? 0;
    message.definition = (object.definition !== undefined && object.definition !== null)
      ? StationDefinition.fromPartial(object.definition)
      : undefined;
    return message;
  },
};

function createBaseGetStationDefinitionRequest(): GetStationDefinitionRequest {
  return {};
}

export const GetStationDefinitionRequest: MessageFns<GetStationDefinitionRequest> = {
  encode(_: GetStationDefinitionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStationDefinitionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStationDefinitionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetStationDefinitionRequest {
    return {};
  },

  toJSON(_: GetStationDefinitionRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetStationDefinitionRequest>, I>>(base?: I): GetStationDefinitionRequest {
    return GetStationDefinitionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetStationDefinitionRequest>, I>>(_: I): GetStationDefinitionRequest {
    const message = createBaseGetStationDefinitionRequest();
    return message;
  },
};

function createBaseStationDefinition(): StationDefinition {
  return { name: "", sensors: [], longitude: 0, latitude: 0, version: 0 };
}

export const StationDefinition: MessageFns<StationDefinition> = {
  encode(message: StationDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.sensors) {
      SensorDefinition.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.longitude !== 0) {
      writer.uint32(25).double(message.longitude);
    }
    if (message.latitude !== 0) {
      writer.uint32(33).double(message.latitude);
    }
    if (message.version !== 0) {
      writer.uint32(40).int32(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StationDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStationDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sensors.push(SensorDefinition.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.longitude = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.latitude = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.version = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StationDefinition {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      sensors: globalThis.Array.isArray(object?.sensors)
        ? object.sensors.map((e: any) => SensorDefinition.fromJSON(e))
        : [],
      longitude: isSet(object.longitude) ? globalThis.Number(object.longitude) : 0,
      latitude: isSet(object.latitude) ? globalThis.Number(object.latitude) : 0,
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
    };
  },

  toJSON(message: StationDefinition): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.sensors?.length) {
      obj.sensors = message.sensors.map((e) => SensorDefinition.toJSON(e));
    }
    if (message.longitude !== 0) {
      obj.longitude = message.longitude;
    }
    if (message.latitude !== 0) {
      obj.latitude = message.latitude;
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StationDefinition>, I>>(base?: I): StationDefinition {
    return StationDefinition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StationDefinition>, I>>(object: I): StationDefinition {
    const message = createBaseStationDefinition();
    message.name = object.name ?? "";
    message.sensors = object.sensors?.map((e) => SensorDefinition.fromPartial(e)) || [];
    message.longitude = object.longitude ?? 0;
    message.latitude = object.latitude ?? 0;
    message.version = object.version ?? 0;
    return message;
  },
};

function createBaseSensorDefinition(): SensorDefinition {
  return { name: "", element: "", recordIntervalSeconds: 0 };
}

export const SensorDefinition: MessageFns<SensorDefinition> = {
  encode(message: SensorDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.element !== "") {
      writer.uint32(18).string(message.element);
    }
    if (message.recordIntervalSeconds !== 0) {
      writer.uint32(24).int64(message.recordIntervalSeconds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SensorDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSensorDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.element = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.recordIntervalSeconds = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SensorDefinition {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      element: isSet(object.element) ? globalThis.String(object.element) : "",
      recordIntervalSeconds: isSet(object.recordIntervalSeconds) ? globalThis.Number(object.recordIntervalSeconds) : 0,
    };
  },

  toJSON(message: SensorDefinition): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.element !== "") {
      obj.element = message.element;
    }
    if (message.recordIntervalSeconds !== 0) {
      obj.recordIntervalSeconds = Math.round(message.recordIntervalSeconds);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SensorDefinition>, I>>(base?: I): SensorDefinition {
    return SensorDefinition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SensorDefinition>, I>>(object: I): SensorDefinition {
    const message = createBaseSensorDefinition();
    message.name = object.name ?? "";
    message.element = object.element ?? "";
    message.recordIntervalSeconds = object.recordIntervalSeconds ?? 0;
    return message;
  },
};

function createBaseStation(): Station {
  return { id: 0, sensors: [], version: 0 };
}

export const Station: MessageFns<Station> = {
  encode(message: Station, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int64(message.id);
    }
    for (const v of message.sensors) {
      Sensor.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.version !== 0) {
      writer.uint32(24).int32(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Station {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sensors.push(Sensor.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.version = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Station {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      sensors: globalThis.Array.isArray(object?.sensors) ? object.sensors.map((e: any) => Sensor.fromJSON(e)) : [],
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
    };
  },

  toJSON(message: Station): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.sensors?.length) {
      obj.sensors = message.sensors.map((e) => Sensor.toJSON(e));
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Station>, I>>(base?: I): Station {
    return Station.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Station>, I>>(object: I): Station {
    const message = createBaseStation();
    message.id = object.id ?? 0;
    message.sensors = object.sensors?.map((e) => Sensor.fromPartial(e)) || [];
    message.version = object.version ?? 0;
    return message;
  },
};

function createBaseSensor(): Sensor {
  return { id: 0, name: "", recordIntervalSeconds: 0 };
}

export const Sensor: MessageFns<Sensor> = {
  encode(message: Sensor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int64(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.recordIntervalSeconds !== 0) {
      writer.uint32(24).int64(message.recordIntervalSeconds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Sensor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSensor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.recordIntervalSeconds = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Sensor {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      recordIntervalSeconds: isSet(object.recordIntervalSeconds) ? globalThis.Number(object.recordIntervalSeconds) : 0,
    };
  },

  toJSON(message: Sensor): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.recordIntervalSeconds !== 0) {
      obj.recordIntervalSeconds = Math.round(message.recordIntervalSeconds);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Sensor>, I>>(base?: I): Sensor {
    return Sensor.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Sensor>, I>>(object: I): Sensor {
    const message = createBaseSensor();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    message.recordIntervalSeconds = object.recordIntervalSeconds ?? 0;
    return message;
  },
};

function createBaseGetSensorStateRequest(): GetSensorStateRequest {
  return { name: "" };
}

export const GetSensorStateRequest: MessageFns<GetSensorStateRequest> = {
  encode(message: GetSensorStateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSensorStateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSensorStateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSensorStateRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetSensorStateRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSensorStateRequest>, I>>(base?: I): GetSensorStateRequest {
    return GetSensorStateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSensorStateRequest>, I>>(object: I): GetSensorStateRequest {
    const message = createBaseGetSensorStateRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseSensorState(): SensorState {
  return { unitId: "", value: undefined, createdAt: 0, intervalStart: undefined };
}

export const SensorState: MessageFns<SensorState> = {
  encode(message: SensorState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.unitId !== "") {
      writer.uint32(18).string(message.unitId);
    }
    if (message.value !== undefined) {
      writer.uint32(25).double(message.value);
    }
    if (message.createdAt !== 0) {
      writer.uint32(32).int64(message.createdAt);
    }
    if (message.intervalStart !== undefined) {
      writer.uint32(40).int64(message.intervalStart);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SensorState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSensorState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.unitId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.value = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.createdAt = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.intervalStart = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SensorState {
    return {
      unitId: isSet(object.unitId) ? globalThis.String(object.unitId) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : undefined,
      createdAt: isSet(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      intervalStart: isSet(object.intervalStart) ? globalThis.Number(object.intervalStart) : undefined,
    };
  },

  toJSON(message: SensorState): unknown {
    const obj: any = {};
    if (message.unitId !== "") {
      obj.unitId = message.unitId;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    if (message.createdAt !== 0) {
      obj.createdAt = Math.round(message.createdAt);
    }
    if (message.intervalStart !== undefined) {
      obj.intervalStart = Math.round(message.intervalStart);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SensorState>, I>>(base?: I): SensorState {
    return SensorState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SensorState>, I>>(object: I): SensorState {
    const message = createBaseSensorState();
    message.unitId = object.unitId ?? "";
    message.value = object.value ?? undefined;
    message.createdAt = object.createdAt ?? 0;
    message.intervalStart = object.intervalStart ?? undefined;
    return message;
  },
};

export type DaemonServiceService = typeof DaemonServiceService;
export const DaemonServiceService = {
  createStation: {
    path: "/recorder.DaemonService/CreateStation",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: StationDefinition): Buffer => Buffer.from(StationDefinition.encode(value).finish()),
    requestDeserialize: (value: Buffer): StationDefinition => StationDefinition.decode(value),
    responseSerialize: (value: Station): Buffer => Buffer.from(Station.encode(value).finish()),
    responseDeserialize: (value: Buffer): Station => Station.decode(value),
  },
  getStation: {
    path: "/recorder.DaemonService/GetStation",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetStationRequest): Buffer => Buffer.from(GetStationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetStationRequest => GetStationRequest.decode(value),
    responseSerialize: (value: Station): Buffer => Buffer.from(Station.encode(value).finish()),
    responseDeserialize: (value: Buffer): Station => Station.decode(value),
  },
  updateStation: {
    path: "/recorder.DaemonService/UpdateStation",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateStationRequest): Buffer => Buffer.from(UpdateStationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateStationRequest => UpdateStationRequest.decode(value),
    responseSerialize: (value: Station): Buffer => Buffer.from(Station.encode(value).finish()),
    responseDeserialize: (value: Buffer): Station => Station.decode(value),
  },
  updateSensors: {
    path: "/recorder.DaemonService/UpdateSensors",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateSensorsRequest): Buffer => Buffer.from(UpdateSensorsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateSensorsRequest => UpdateSensorsRequest.decode(value),
    responseSerialize: (value: UpdateSensorsResponse): Buffer =>
      Buffer.from(UpdateSensorsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): UpdateSensorsResponse => UpdateSensorsResponse.decode(value),
  },
  ping: {
    path: "/recorder.DaemonService/Ping",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PingMessage): Buffer => Buffer.from(PingMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer): PingMessage => PingMessage.decode(value),
    responseSerialize: (value: PingMessage): Buffer => Buffer.from(PingMessage.encode(value).finish()),
    responseDeserialize: (value: Buffer): PingMessage => PingMessage.decode(value),
  },
} as const;

export interface DaemonServiceServer extends UntypedServiceImplementation {
  createStation: handleUnaryCall<StationDefinition, Station>;
  getStation: handleUnaryCall<GetStationRequest, Station>;
  updateStation: handleUnaryCall<UpdateStationRequest, Station>;
  updateSensors: handleUnaryCall<UpdateSensorsRequest, UpdateSensorsResponse>;
  ping: handleUnaryCall<PingMessage, PingMessage>;
}

export interface DaemonServiceClient extends Client {
  createStation(
    request: StationDefinition,
    callback: (error: ServiceError | null, response: Station) => void,
  ): ClientUnaryCall;
  createStation(
    request: StationDefinition,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Station) => void,
  ): ClientUnaryCall;
  createStation(
    request: StationDefinition,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Station) => void,
  ): ClientUnaryCall;
  getStation(
    request: GetStationRequest,
    callback: (error: ServiceError | null, response: Station) => void,
  ): ClientUnaryCall;
  getStation(
    request: GetStationRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Station) => void,
  ): ClientUnaryCall;
  getStation(
    request: GetStationRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Station) => void,
  ): ClientUnaryCall;
  updateStation(
    request: UpdateStationRequest,
    callback: (error: ServiceError | null, response: Station) => void,
  ): ClientUnaryCall;
  updateStation(
    request: UpdateStationRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Station) => void,
  ): ClientUnaryCall;
  updateStation(
    request: UpdateStationRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Station) => void,
  ): ClientUnaryCall;
  updateSensors(
    request: UpdateSensorsRequest,
    callback: (error: ServiceError | null, response: UpdateSensorsResponse) => void,
  ): ClientUnaryCall;
  updateSensors(
    request: UpdateSensorsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: UpdateSensorsResponse) => void,
  ): ClientUnaryCall;
  updateSensors(
    request: UpdateSensorsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: UpdateSensorsResponse) => void,
  ): ClientUnaryCall;
  ping(request: PingMessage, callback: (error: ServiceError | null, response: PingMessage) => void): ClientUnaryCall;
  ping(
    request: PingMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PingMessage) => void,
  ): ClientUnaryCall;
  ping(
    request: PingMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PingMessage) => void,
  ): ClientUnaryCall;
}

export const DaemonServiceClient = makeGenericClientConstructor(
  DaemonServiceService,
  "recorder.DaemonService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): DaemonServiceClient;
  service: typeof DaemonServiceService;
  serviceName: string;
};

export type StationInterfaceService = typeof StationInterfaceService;
export const StationInterfaceService = {
  getStationDefinition: {
    path: "/recorder.StationInterface/GetStationDefinition",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetStationDefinitionRequest): Buffer =>
      Buffer.from(GetStationDefinitionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetStationDefinitionRequest => GetStationDefinitionRequest.decode(value),
    responseSerialize: (value: StationDefinition): Buffer => Buffer.from(StationDefinition.encode(value).finish()),
    responseDeserialize: (value: Buffer): StationDefinition => StationDefinition.decode(value),
  },
  getSensorState: {
    path: "/recorder.StationInterface/GetSensorState",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetSensorStateRequest): Buffer =>
      Buffer.from(GetSensorStateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetSensorStateRequest => GetSensorStateRequest.decode(value),
    responseSerialize: (value: SensorState): Buffer => Buffer.from(SensorState.encode(value).finish()),
    responseDeserialize: (value: Buffer): SensorState => SensorState.decode(value),
  },
} as const;

export interface StationInterfaceServer extends UntypedServiceImplementation {
  getStationDefinition: handleUnaryCall<GetStationDefinitionRequest, StationDefinition>;
  getSensorState: handleUnaryCall<GetSensorStateRequest, SensorState>;
}

export interface StationInterfaceClient extends Client {
  getStationDefinition(
    request: GetStationDefinitionRequest,
    callback: (error: ServiceError | null, response: StationDefinition) => void,
  ): ClientUnaryCall;
  getStationDefinition(
    request: GetStationDefinitionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: StationDefinition) => void,
  ): ClientUnaryCall;
  getStationDefinition(
    request: GetStationDefinitionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: StationDefinition) => void,
  ): ClientUnaryCall;
  getSensorState(
    request: GetSensorStateRequest,
    callback: (error: ServiceError | null, response: SensorState) => void,
  ): ClientUnaryCall;
  getSensorState(
    request: GetSensorStateRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SensorState) => void,
  ): ClientUnaryCall;
  getSensorState(
    request: GetSensorStateRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SensorState) => void,
  ): ClientUnaryCall;
}

export const StationInterfaceClient = makeGenericClientConstructor(
  StationInterfaceService,
  "recorder.StationInterface",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): StationInterfaceClient;
  service: typeof StationInterfaceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
